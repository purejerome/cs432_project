// Purpose: Valid, side-effectful test for evaluation order in a[foo()] = a[foo()]
// In Decaf, the LHS (location) must be evaluated before the RHS (value).

int g[1];  // use 1-slot array as mutable global counter g[0]

// foo(): returns current g, then increments it by 1
def int foo() {
  int old;
  old = g[0];
  g[0] = g[0] + 1;
  return old;
}

def int main() {
  int a[5];
  // Init counter and array (all indexes used are in-bounds)
  g[0] = 1;
  a[0] = 100;
  a[1] = 200;
  a[2] = 300;
  a[3] = 400;
  a[4] = 500;

  // Key statement under test:
  // Correct evaluation (LHS first):
  //   LHS index = foo() -> returns 1; g becomes 2
  //   RHS index = foo() -> returns 2; g becomes 3
  //   => a[1] = a[2]  so a becomes [100,300,300,400,500]
  //
  // Wrong evaluation (RHS first):
  //   RHS index = foo() -> returns 1; g becomes 2
  //   LHS index = foo() -> returns 2; g becomes 3
  //   => a[2] = a[1]  so a becomes [100,200,200,400,500]
  //
  // Both outcomes are valid arrays (no OOB), but different â€” revealing order.
  a[foo()] = a[foo()];

  // Show result clearly
  print_int(a[0]); print_str(" ");
  print_int(a[1]); print_str(" ");
  print_int(a[2]); print_str(" ");
  print_int(a[3]); print_str(" ");
  print_int(a[4]); print_str("\n");

  // Return a checksum to make diffs extra obvious
  return a[0] + a[1] + a[2] + a[3] + a[4];
}
